#!/usr/bin/env python

import numpy as np
import sys
import argparse
import pandas as pd
import pyinventrry as pi
import pyinventrry.util as ut

sType = ['Whole', 'Consonant','Stop/affricate', 'Vowel']

def calculate_meta_keys(data_frame):
	'''
	Find all colummns name which start with an underscore
	:param data_frame: the DataFrame to analyse.
	:type data_frame: DataFrame
	:return: the list of all meta keys of the DataFrame
	:rtype: string array
	'''
	all = [ x for x in data_frame ]
	meta = []
	for k in all :
		if k=='' or k[0]=='_' :
			meta.append(k)
	return meta

def calculate_unique(data_frame, acc, meta):
	'''
	Calculate all unique meta_data tuples in a dataframe
	:param data_frame: The DataFrame to analyse
	:param acc: an accumulator with part of tuples already known
	:param meta: the list of yet unanalysed meta keys
	:type data_frame: DataFrame
	:type acc: A tuple array array
	:type meta: string array
	:return: the list of all unique meta_value in the DataFrame
	:rtype: tuple array array
	'''
	new_acc = [b]
	m_key = meta.pop()
	tmp = pd.DataFrame(data_frame)
	for k in acc :
		for tk in k :
			tmp = tmp.loc[tmp[tk[0]]==tk[1]]
		uni = tmp[m_key].unique()
		for n in uni :
			new_key = list(k)
			new_key.append((m_key,n))
			new_acc.append(new_key)
	if meta :
		return calculate_unique(dataframe, new_acc, meta)
	else :
		return new_acc

def extract_data_frame(data_frame, tuples):
	'''
	Extract the part of the DataFrame which matchs the meta_values given in argument
	:param data_frame: The DataFrame which is going to be parsed
	:param tuples: An array containing (k,v) tuples with k a columns name and v a value in this columns
	:type data_frame: DataFrame
	:type tuples: A tuple array
	:return: The part of  DataFrame corresponding to the tuples argument 
	:rtype: DataFrame
	'''
	ret = pd.DataFrame(data_frame)
	for t in tuples :
		ret = ret.loc[ret[t[0]]==t[1]]
		ret.drop(t[0],axis=1)
	return ret

def calculate_score( inv_whole, spec_whole, norm_tab ) : 
	'''
	Calculate and print economic, local and global scores 
	:param inv_whole:
	:param spec_whole:
	:param norm_tab:
	:type inv_whole:
	:type spec_whole:
	:type norm_tab:
	:return:
	:rtype:
	'''
	meta_keys = calculate_meta_keys(inv_whole)
	unique = calculate_unique(inv_whole,[[]], list(meta_keys))
	result = pd.DataFrame(columns=meta_keys+['econ','loc','glob'])
	print(result)
	for t in unique:
		inv = extract_data_frame(inv_whole, t)
		spe = extract_data_frame(spec_whole, t)
		leng = spe.shape[0] 
		for spec in range(leng) : 
			result = pd.DataFrame(columns=meta_keys+['econ','loc','glob'])
			e, l, g = pi.stats.stat(inv, (ut.get_true_specs(spe.iloc[spec].to_dict())),norm_tab)
			d = dict(t)
			d['econ'] = e
			d['loc'] = l
			d['glob'] = g
			result = result.append(d, ignore_index=True)
			print(result.to_string(header=False))
	return result

if __name__ == "__main__":
	parser = argparse.ArgumentParser()
	parser.add_argument("inventory", help = 'A csv file with the correct format for the inventory')
	parser.add_argument("specs", help = 'A csv file with the correct format for the specs')
	parser.add_argument("norm_tab", help = 'A file used for normalize data (actually in feather format)')
	#parser.add_argument('--max-cost', type=float,
	#					default=float("inf"))
	#parser.add_argument('--seed', type=int, default=None)
	#parser.add_argument('inventory_fn',
	#					help='csv containing features for a single inventory,'
	#					' with header, coded numerically')
	args = parser.parse_args(sys.argv[1:])
	print(args)
	print(sys.argv[1:])
	dict = calculate_score(	pd.read_csv(args.inventory),
				pd.read_csv(args.specs), 
				pd.read_feather(args.norm_tab) )
	print("\ndone")
